
# Render pipeline (RAII-based resource management)

> 일자: 2025.08  
> 언어: C++(DirectX11)  
> 목표: 렌더 타겟 별 패스 실행 추상화 및 리소스 수명 관리  

### 개요

- ```Renderer```에서 GameObject 들의 렌더 요청을 모아 한번에 처리
- 요청에 따라 그려야할 멀티 렌더 타겟을 바인딩하여 때로는 쉐이더 패스까지 제공
- 해당 과정에서 핸들의 반환이나 단일성을 검사해주는 wrapper 클래스```CMultiTargetRendererHandle``` 생성

> **핵심 아이디어**
> - 렌더 타겟 패스를 자유롭게 
> - 생성하여 바인딩하고 소멸하면 원상태로 복구하는 스코프 가드  
> - 단일 실행만을 허용하여 오용 방지

### 구성
```
/Render pipeline
  ├─ RenderTarget.h / .cpp 	# DirectX11 타겟 래퍼 (Texture2D + RTV + SRV)
  ├─ Renderer.h / .cpp 		# 렌더 큐/패스 실행
  ├─ MultiRenderTargetHandle.h / .cpp # 멀티 렌더 타겟 wrapper. 어디에 그릴지를 스코프로 관리.
  ```

### 성능/운영 팁

- 렌더 타겟 패스 단위로 가드 사용
- 스코프 단위 바인딩/복구로 누수와 초기화 미스 방지
- 오브젝트가 쉐이더 패스를 직접 지정하거나, 일괄적으로 렌더러에서 지정할 수도 있는 유연한 구조
- Renderer에서는 가능한 예외처리를 내지 않도록 매 테스트에서 assert()로 유효성 검사

### 한계 및 개선 여지

- 하나의 오브젝트를 여러 렌더 타겟 패스에서 사용하고 싶을 때, 범용적인 Render() 함수가 아니며 각각의 상황에 맞게 사용하기 어려울 수 있음
- 각 패스별 결과 텍스쳐에 대한 별도의 스냅샷 기능
- OM 리소스를 주로 관리하고 있으며, Depth, 블렌딩 규칙 등 추가적인 유틸성 부족
- 일부 예외 처리를 생략하면서, 기기 호환 등 예상치 못한 처리 불가능할 수 있음
